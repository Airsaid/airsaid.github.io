{"meta":{"title":"Airsaid's Blog","subtitle":"为写出优雅的代码而努力","description":"Android | Java | 数据结构 | 算法 | 设计模式 | 技术分享 | 个人博客","author":"Airsaid","url":"http://airsaid.github.io"},"pages":[{"title":"","date":"2018-04-22T13:50:56.241Z","updated":"2018-04-22T13:50:56.116Z","comments":true,"path":"404.html","permalink":"http://airsaid.github.io/404.html","excerpt":"","text":"404 NOT FOUND回到主页"},{"title":"","date":"2018-04-22T13:50:56.373Z","updated":"2018-04-22T13:50:56.134Z","comments":false,"path":"categories/index.html","permalink":"http://airsaid.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-22T13:50:56.378Z","updated":"2018-04-22T13:50:56.134Z","comments":false,"path":"tags/index.html","permalink":"http://airsaid.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 约束布局（ConstraintLayout）1.1.0 版详解","slug":"Android-ConstraintLayout-1.1.0-Detailed","date":"2018-04-22T13:41:58.000Z","updated":"2018-04-22T13:50:56.116Z","comments":true,"path":"20180422/Android-ConstraintLayout-1.1.0-Detailed/","link":"","permalink":"http://airsaid.github.io/20180422/Android-ConstraintLayout-1.1.0-Detailed/","excerpt":"本篇 ConstraintLayout 讲解版本：1.1.0 稳定版","text":"本篇 ConstraintLayout 讲解版本：1.1.0 稳定版 前言在上一篇文章中，我们对 ConstraintLayout 1.0.2 版进行了详细的了解。而当时说好的 1.1 版本的文章却直到现在才出来，相隔了好久。其实关于 1.1 beta 版的文章早已经写完，但却一直没有发布，这是因为当时担心后面的稳定版会和现有的冲突（事实上的确有），所以一直到本周四，Google 宣布 ConstraintLayout 1.1 正式版发布，于是在周末休息时重新整理发布了这篇文章。 如果对 ConstraintLayout 不了解，并且还没有观看上篇文章的，强烈建议先观看完上篇文章，因为本篇只是对上篇的补充。如果有遗落或错误，欢迎各位补充和指正。 准备1implementation 'com.android.support.constraint:constraint-layout:1.1.0' Circular Positioning圆形定位（Circular Positioning）可以让一个控件以另一个控件的中心为中心点，来设置其相对与该中心点的距离和角度。可以设置的属性有： layout_constraintCircle：引用另一个控件的 id。 layout_constraintCircleRadius：到另一个控件中心的距离。 layout_constraintCircleAngle：控件的角度（顺时针，0 - 360 度）。 下面以给头像设置 badge 为例，演示下其用法：123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.github.airsaid.constraintlayoutdemo.MainActivity\"&gt; &lt;ImageView android:id=\"@+id/img_avatar\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:src=\"@mipmap/ic_avatar\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/txt_label\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"VIP\" android:textColor=\"#FFFF00\" android:textStyle=\"bold\" app:layout_constraintCircle=\"@id/img_avatar\" app:layout_constraintCircleAngle=\"45\" app:layout_constraintCircleRadius=\"30dp\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 运行结果： Enforcing constraints在 1.1 版本之前，如果将控件的尺寸设置为了 WRAP_CONTENT，那么对控件设置约束（如：minWidth 等）是不起作用的。那么强制约束（Enforcing constraints）的作用就是，在控件被设置 WRAP_CONTENT 的情况下，使约束依然生效。 需要使用到的属性有： app:constrainedWidth=”true|false” app:constrainedHeight=”true|false” 下面的例子演示了没有设置强制约束和设置了强制约束的对比： 12345678910111213141516171819202122&lt;ImageView android:id=\"@+id/img_avatar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_avatar\" app:layout_constrainedWidth=\"false\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintWidth_max=\"100dp\" /&gt;&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_avatar\" app:layout_constrainedWidth=\"true\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/img_avatar\" app:layout_constraintWidth_max=\"100dp\" /&gt; 运行结果： Dimensions1.1 版本中，当控件的尺寸设置为了 MATCH_CONSTRAINT 时（ 0dp），在设置尺寸上又多了二个新的修饰属性： layout_constrainWidth_percent。 layout_constrainHeight_percent。 这两个属性的作用就是指定当前控件的宽度或高度是父控件的百分之多少。可设置的值在 0 - 1 之间，1 就是 100%。 设置头像的宽度占父控件宽度的 80%（父控件占满全屏）例子： 1234567891011&lt;ImageView android:id=\"@+id/img_avatar\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@mipmap/ic_avatar\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintWidth_percent=\"0.8\" /&gt; 运行结果： Margins and chains在 1.1.0-beta4 版本中（已知），为链中的控件设置 marginRight/End 是无效的（个人感觉这应该是个 Bug）。而在 1.1 稳定版中，无论设置右边距还是左边距都是有效果的，会累计计算。并且在计算剩余空间时，会将边距一起考虑。 Optimizer需要知道的是，当我们使用 MATCH_CONSTRAINT 时，ConstraintLayout 将不得不对控件进行 2 次测量，而测量的操作是昂贵的。 而优化器（Optimizer）的作用就是对 ConstraintLayout 进行优化，对应设置给 ConstraintLauyout 的属性是： layout_optimizationLevel。 可设置的值有： none：不应用优化。 standard：仅优化直接约束和屏障约束（默认的）。 direct：优化直接约束。 barrier：优化屏障约束。 chain：优化链约束（实验）。 dimensions：优化尺寸测量（实验）。 在设置值时，可以设置多个，如：1app:layout_optimizationLevel=&quot;direct|barrier|dimensions&quot; Barrier当我们在布局时，有时候就会遇到布局会随着数据的多少而改变大小的情况。以下图为例： （图片来自官方） 通过上图就可以发现，当在 A、B 控件的大小都不确定的情况下， View3 以谁作为约束对象都不对。如果以 A 作为约束对象，那么当 B 的宽度过宽时就会被遮挡，同理以 B 作为约束也是如此。 那么此时，Barrier（屏障）就派上用场了。这是个非常好用的东东，和 GuideLine 一样，它是一个虚拟的 View，对界面是不可见的。目的就是辅助布局。 对 Barrier 可以使用的属性有： barrierDirection：设置 Barrier 所创建的位置。可设置的有：bottom、end、left、right、start、top。 constraint_referenced_ids：设置 Barrier 引用的控件。可设置多个，设置的方式是：id, id。（无需加 @id/） barrierAllowsGoneWidgets：默认为 true，即当 Barrier 引用的控件被 GONE 掉时，则 Barrier 默认的创建行为是在已 GONE 掉控件的已解析位置上进行创建。如果设置为 false，则不会将 GONE 掉的控件考虑在内。 说再多不如看代码，还是以上图为例，来看看 Barrier 是如何解决的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"16dp\" tools:context=\"com.github.airsaid.constraintlayoutdemo.MainActivity\"&gt; &lt;TextView android:id=\"@+id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Title\" android:textSize=\"16sp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/desc\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:text=\"This is a descriptive text.\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/title\" /&gt; &lt;android.support.constraint.Barrier android:id=\"@+id/barrier\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:barrierDirection=\"end\" app:constraint_referenced_ids=\"title, desc\" /&gt; &lt;TextView android:id=\"@+id/content\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"10dp\" android:text=\"This is a piece of content that is very long and long very long and long ...\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toEndOf=\"@id/barrier\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 运行结果： 另一种情况： 完美解决。 GroupGroup 的作用就是控制一组控件的可见性。其可使用到的属性为： constraint_referenced_ids：指定所引用控件的 id。 例： 12345&lt;android.support.constraint.Group android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\" app:constraint_referenced_ids=\"title, desc\" /&gt; 如果有多个 Group，是可以同时指定相同的控件的，最终是以 XML 中最后声明的 Group 为准。 PlaceholderPlaceholder（占位符）是一个虚拟对象，作用和它的名字一样，就是占位。 当放置好 Placeholder 后，可以通过 setContentId() 方法将占位符变为有效的视图。如果视图已经存在于屏幕上，那么视图将会从原有位置消失。 除此之外，还可以通过 setEmptyVisibility() 方法设置当视图不存在时占位符的可见性。 下面的例子演示了占位符的使用，当点击顶部头像时，顶部头像会消失并在占位符处显示： 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"16dp\" tools:context=\"com.github.airsaid.constraintlayoutdemo.MainActivity\"&gt; &lt;ImageView android:id=\"@+id/avatar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_avatar\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;android.support.constraint.Placeholder android:id=\"@+id/placeholder\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 运行结果： 总结可以看到 ConstraintLayout 在不断的强大，并且更是推出了优化器来让性能更出色。那么，还有什么理由不用 ConstraintLayout 呢？！","categories":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/tags/Android/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://airsaid.github.io/tags/ConstraintLayout/"}]},{"title":"Android 约束布局（ConstraintLayout）详解","slug":"Android-ConstraintLayout-Detailed","date":"2018-02-05T03:32:48.000Z","updated":"2018-04-22T13:50:56.117Z","comments":true,"path":"20180205/Android-ConstraintLayout-Detailed/","link":"","permalink":"http://airsaid.github.io/20180205/Android-ConstraintLayout-Detailed/","excerpt":"本篇 ConstraintLayout 讲解版本：1.0.2，1.1.x 版本开始新增功能在下篇进行讲解","text":"本篇 ConstraintLayout 讲解版本：1.0.2，1.1.x 版本开始新增功能在下篇进行讲解 前言ConstraintLayout 是一个 ViewGroup，它的出现是为了解决复杂布局时，布局嵌套（布局内的布局）过多的问题（嵌套布局会增加绘制界面所需的时间）。它可以根据同级视图和父布局的约束条件为每个视图定义位置，类似于 RelativeLayout 所有视图都是根据兄弟视图和父级布局之间的关系来布局的，但是与 RelativeLayout 相比，它更加灵活，更易于使用。 在 Android 2.2 的版本中，为了给 ConstraintLayout 提供支持，Android 设计了新的布局编辑器。我们可以直接在布局编辑器当中拖动控件、添加约束，一气呵成。当然，在布局编辑器当中所做的操作，XML 布局当中就会自动生成对应的属性。 其中生成的一些属性，有可能并不是必须需要的。所以在生成后，你可能还需要手动检查、清理一下。或者你也可以直接在 XML 中编写属性，ConstraintLayout 的属性虽多，但是都是成组的，还是很容易掌握的。 约束概述要在 ConstraintLayout 中定义 View 的位置，必须为该 View 添加至少一个水平和垂直约束（否则该 View 就会在左上角绘制）。该约束对象可以是另一个视图，或者父布局（也就是 ConstraintLayout），或者是不可见的 Guideline（后面会讲 Guideling）等。 如果有缺少的约束（或其他的一些优化问题），编辑器会在右上角显示警告提示（编译器不会错误）： 警告提示（提示有 5 处可修复和优化的地方） 正常情况 转换布局如果要将现有布局转换为约束布局，只需按照下列步骤操作： 在 Android Studio 中打开布局，然后单击编辑器窗口底部的 Design 选项卡。 在 Component Tree 窗口中，右键单击布局，然后单击 Convert layout to ConstraintLayout。 转换布局 开始要在项目中使用 ConstraintLayout，我们需要在 build.gradle 中添加依赖（新版 AndroidStudio 会默认添加）： 1compile 'com.android.support.constraint:constraint-layout:1.0.2' 然后，在工具栏中同步 Gradle 文件。 创建布局接下来，我们创建一个布局，根布局就用 ConstraintLayout： 123456789&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 添加约束添加约束十分简单，我们首先从 Design 界面的 Palette 操作栏拖动一个 Button 到蓝图中，添加完后，点击选中它，效果是这样的： 蓝图效果 可以看到，上下左右都有一个小圆圈，这个圆圈就是用来添加约束的。 四个角的矩形，是用来扩大或缩小控件的。 删除该控件上所有约束 编辑基线，用于基线对齐（下面会说） 现在我们来为这个 Button 添加约束： 添加约束（约束对象为父控件） 看这个效果，有没有一种「四马分尸」的感觉？当只有一条边拉这个 Button 时，Button 马上就被拉过去了，但是当四个边都开始拉这个 Button 时，Button 就在中间动弹不得了。 看完了动图，我们再来看看 XML 布局中的变化： 12345678910111213&lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintTop_toTopOf=\"parent\" android:layout_marginTop=\"8dp\" android:layout_marginLeft=\"8dp\" app:layout_constraintLeft_toLeftOf=\"parent\" android:layout_marginRight=\"8dp\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" android:layout_marginBottom=\"8dp\"/&gt; 因为我们的目的是想让这个 Button 居中，但是它却默认给我们添加了 margin，这个显然是多余的。 如果不想每次添加约束后都在这条边的约束上添加 margin，我们可以在上面的工具栏中进行设置： 设置控件默认的 margin 抛去 margin 相关的属性，那么约束父控件的相关属性就是如下这些了： 1app:layout_constraintTop_toTopOf=\"parent\" 1app:layout_constraintLeft_toLeftOf=\"parent\" 1app:layout_constraintRight_toRightOf=\"parent\" 1app:layout_constraintBottom_toBottomOf=\"parent\" 在上面的图中我们已经看到了，每个控件的上下左右都有一个圆圈，用于添加约束的。 那么这些属性的 constraintXXX 就是指定的当前控件的约束位置的，而 toXXX 就是目标约束位置。 这个位置可以是上面的例子一样是 parent（也就是父控件），也可以是另一个控件。 接下来我们再来看看对于其他控件的约束。 再拖一个 Buttton 进入蓝图中，然后给这个 Button 添加约束： 添加约束（约束对象为另一个控件） XML 布局： 12345678910&lt;Button android:id=\"@+id/button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintLeft_toLeftOf=\"@+id/button\" app:layout_constraintRight_toRightOf=\"@+id/button\" android:layout_marginTop=\"48dp\" app:layout_constraintTop_toBottomOf=\"@+id/button\"/&gt; 添加完约束了，如果要删除指定的单个约束的话，单击变红的圆圈即可： 删除指定的单个约束 或者是上面提到了，删除指定控件的所有约束。 或者是工具栏中的，删除页面所有的约束： 删除页面所有的约束 基线约束基线约束的作用就是将视图的文本基线与另一个视图的文本基线对齐： 添加基线约束 添加完成后，在 XML 布局中，B 控件就会多出这么一个属性： 1app:layout_constraintBaseline_toBaselineOf=\"@+id/a\" 该属性就是用于基线对齐的。 ChainsChains（链）是一种特定的约束，一个链包含了多个视图，它允许链中的视图共享空间，并控制可用空间在它们之间如何分配。该效果与 LinearLayout 的 Weiget 类似，但是链的作用远远超过它。 我们要是想创建一个链，那么首先就需要创建多个视图控件，然后再选择是创建「水平链」还是「垂直链」。 让我们从三个视图中创建一个「水平链」： 创建「水平链」 「垂直链」： 创建「垂直链」 以「水平链」为例，我们来看看它们的样子： 「水平链」 可以发现，两侧控件的约束样子和前面约束的样子是一样的，我把它称之为「单约束」，也就是两侧控件只是单方面的约束了对方（这里是父控件）。 而中间的控件，两侧的约束则是链条的样子，这表示它约束了左右侧控件，而左右侧控件同样也约束了它：「互相约束」。 在 XML 布局中，是通过如下属性实现的： 1234567891011121314151617181920212223242526&lt;Button android:id=\"@+id/button1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toLeftOf=\"@+id/button2\" tools:layout_editor_absoluteY=\"69dp\"/&gt;&lt;Button android:id=\"@+id/button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintLeft_toRightOf=\"@+id/button1\" app:layout_constraintRight_toLeftOf=\"@+id/button3\" tools:layout_editor_absoluteY=\"69dp\"/&gt;&lt;Button android:id=\"@+id/button3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintLeft_toRightOf=\"@+id/button2\" app:layout_constraintRight_toRightOf=\"parent\" tools:layout_editor_absoluteY=\"69dp\"/&gt; 我们刚刚创建好了一条链，此时我们可以设置 Cycle Chain Mode（链式模式）来告诉 Chains：“你应该怎样去填充剩余的空间”。 在「蓝图」中，设置的方式是点击链条的小图标： 多出来了链条图标 在「布局」中，设置的属性是： 1layout_constraintHorizontal_chainStyle 1layout_constraintVertical_chainStyle 分别对应着「水平链」和「垂直链」。 有三种可选的参数： spread：将可用空间以均匀分布的方式将视图放置在链中（默认模式）： spread spread_inside：将链中最外面的视图对齐到外边缘，然后在可用空间内均匀的放置链中的其他视图： spread_inside packed：将链中的视图紧紧的放在一起（可以提供边距让其分开），然后让其居中在可用空间内： packed 除了上面说的之外，Chains 还能对链中单独的视图控件设置 Weiget。因为目前并不支持在编辑器当中设置 Weiget，所以我们只能在布局中进行设置了，设置的属性是： 1layout_constraintHorizontal_weight 1layout_constraintVertical_weight 我们现在将第一个 Button 填充完剩余的空间，在该 Buttton 上设置如下属性： 1android:layout_width=\"0dp\" 1app:layout_constraintHorizontal_weight=\"1\" weight 效果 使用和 LinearLayout 的 Weiget 一致，很好理解。 Properties基本的添加、删除约束我们已经掌握了，那么现在再来将目光转向右侧的 Properties 区域。 Properties 该区域分为了上下两个部分，下部分就是选中控件的一些属性什么的，很好理解。 重点来看看上半部分，该部分被称为：Inspector 区域。 Inspector 首先来看这些数字，很明显就是当前控件的 margin 值，我们可以直接在上面进行修改： 修改控件的 margin 还有就是左边和下边的两个轴，我把它称之为纵横轴。作用是用于确定控件位置的： 修改纵横轴 根据上图可以看到，因为该控件同时添加了水平和垂直约束，所以两条轴都可以进行操作。 轴上面的数字是比例，对应的属性如下： 12app:layout_constraintVertical_bias=&quot;0.5&quot;app:layout_constraintHorizontal_bias=&quot;0.5&quot; 再来看看中心区域： Inspector 中心区域 四条边的原点就是添加的约束，点击的作用是删除该约束。 重要的是中心的 &lt;&lt;&lt;，这个代表了当前控件的宽高计算方式。点击是可以切换的，一共有三种： ：这个代表的就是 wrap_content，不用过多解释了。 ：这个就是指定宽高的大小。 ：这个代表的是：Match Constraints（有点类似于 match_parent），就给强翻成约束匹配吧… 这个是 ConstraintLayout 特有的，它会尽可能扩展以满足各方的约束（在考虑视图边界之后）。但是，可以使用以下属性和值修改该行为（只有在将视图宽度设置为与约束匹配时，这些属性才会生效）： layout_constraintWidth_default： spread：这是默认的行为，它会尽可能的扩展视图来满足约束。 wrap：与上面所说的 wrap_content 不同的是，虽然都是适应内容，但仍然允许视图比约束要求的视图更小。 layout_constraintWidth_min：指定视图的最小宽度（dp）。​ - layout_constraintWidth_max：指定视图的最大宽度（dp）。 下面来几个例子，演示下约束匹配的效果，比如说，要让一个 Button 宽度填充满，仅需要将宽度设置为 0dp 即可： 1android:layout_width=\"0dp\" 如果是两个 Button： 12345678910111213141516171819&lt;Button android:id=\"@+id/button1\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"A\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt;&lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"B\" app:layout_constraintTop_toBottomOf=\"@+id/button1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\"/&gt; 效果： 约束匹配效果 设置宽高比例当宽高至少有一项设置为 0dp 时（也就是 Match Constraints），那么我们就可以为该视图设置宽高比例。设置的属性是： 1layout_constraintDimensionRatio 如： 123456&lt;Button android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"button\" app:layout_constraintDimensionRatio=\"3:1\"/&gt; 设置宽高比 参数是一个浮点值：“宽度：高度”，在该例子中，表示的宽高比是 3:1，也就是高度是宽度的三分之一。 当我们的宽高都设置为 0dp 时，如： 1234567&lt;Buttona android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"button\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\"/&gt; 此时，该视图是不会显示的，虽然我们加了 left 和 rigth 约束到父控件，让它知道了它的宽度就是父控件的高度，但是此时它还并不知道自己有多高。所以此时我们在添加 ration 时，则可以指示哪一方应该受到约束，方法是在比率前面添加字母 W（用于限制宽度）或 H（用于限制高度），用逗号分隔： 1app:layout_constraintDimensionRatio=\"h, 3:1\" 这里设置的宽高比例是 3:1，那么高度就只有宽度的三分之一了： 设置宽高比 GuidelinesGuidelines 是一条对实际显示界面不可见的线。用处是帮助我们的控件增加约束。 我们可以通过该图标来添加垂直或者水平的 Guidelines： 添加 Guideline 比如我们想让控件在中心显示： Guideline 演示 可以看到 Guidelines 可以切换百分比，或者是实际的距离。具体用哪种还是得根据实际情况来。 自动添加约束有两种方式实现自动添加约束，分别是： Autoconnect：这是一个独立的功能，默认是关闭的。我们可以开启它，开启后，它将自动为新添加的视图创建两个或者更多的约束。其他的视图则不会自动添加，如： Autoconnect Infer Constraints：为当前所有的视图自动添加约束： Infer Constraints 参考 https://developer.android.com/training/constraint-layout/index.html?hl=zh-cn#add-constraintlayout-to-your-project https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html https://constraintlayout.com/ http://blog.csdn.net/guolin_blog/article/details/53122387","categories":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/tags/Android/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://airsaid.github.io/tags/ConstraintLayout/"}]},{"title":"使用 Android Support Annotations 库来优化你的代码","slug":"Use-Android-Support-Annotations-library-optimize-code","date":"2018-02-02T09:48:00.000Z","updated":"2018-04-22T13:50:56.133Z","comments":true,"path":"20180202/Use-Android-Support-Annotations-library-optimize-code/","link":"","permalink":"http://airsaid.github.io/20180202/Use-Android-Support-Annotations-library-optimize-code/","excerpt":"Android Support Library 从 19.1 版本开始引入了一个新的注解库（Android Support Annotations Library），其中包含了很多的元注解，使用它们修饰我们的代码， 可以让我们提高程序的开发效率，让我们更早的发现问题。以及对代码施以规范，让代码更加有可读性。这篇文章就来简单了解下这些注解，以及其使用。如有错误和遗漏，欢迎留言和补充～","text":"Android Support Library 从 19.1 版本开始引入了一个新的注解库（Android Support Annotations Library），其中包含了很多的元注解，使用它们修饰我们的代码， 可以让我们提高程序的开发效率，让我们更早的发现问题。以及对代码施以规范，让代码更加有可读性。这篇文章就来简单了解下这些注解，以及其使用。如有错误和遗漏，欢迎留言和补充～ 准备在 build.gradle 中添加依赖库： 123dependencies &#123; compile 'com.android.support:support-annotations:22.2.0'&#125; 注：在新版本的 AndroidStudio 下，新建的项目就直接依赖了 support.appcompat 包，而其中已经有了 annotations 包，所以不必重复添加。如果你在使用下面的注解时发现找不到对应的注解，那么再按照如上步骤添加依赖库即可。 @IntDef &amp; @StringDef替代 Java 中枚举的注解，以 @IntDef 为例，定义和使用如下：12345678910@IntDef(&#123;RED, BLUE, YELLOW&#125;)@Retention(RetentionPolicy.SOURCE)public @interface LightColors&#123;&#125;;public static final int RED = 1;public static final int BLUE = 2;public static final int YELLOW = 3;public void setColor(@LightColors int color)&#123;&#125; @interface：声明新的枚举注解类型。 @Retention(RetentionPolicy.SOURCE)：告知编译器不将枚举的注解数据存储在 .class 文件中。 如果允许常量与标志（例如：|、&amp; 和 ^ 等等）相结合，则我们可以使用 flag 属性，如：1@IntDef(flag = true, value = &#123;RED, BLUE, YELLOW&#125;) 使用：1setColor(RED | BLUE); @Nullable &amp; @NonNull @Nullable：注解的元素可以为 null。 @NonNull：注解的元素不可以为 null。 上面的注解可以修饰如下元素：1，方法参数。如：12@Nullableprivate String data; 2，方法的返回值。 如：1234@Nullablepublic String getData()&#123; return data;&#125; 3，成员属性。如：12public void setData(@Nullable String data)&#123;&#125; 当用空的参数传给被 @NonNull 修饰的方法参数的方法时，会给出如下警告提示（编译不会报错）：1passing \"null\" argument to parameter annotated as @NotNull @FloatRange &amp; @IntRange@FloatRange 和 @IntRange 是用于限定范围的注解。其中 @FloatRange 是限定 float 类型的，而 @IntRange 是限定 int 类型的。它们同上注解一样，可以修饰方法参数、方法返回值、成员属性。 以 @IntRange 为例，修饰方法参数的定义如下：12public void setAge(@IntRange(from = 1, to = 180) int age)&#123;&#125; 如果调用该方法传的参数不在 1 - 180 的范围内， 如：setAge(0)，那么编译会直接报如下错：1value must be ≥ 1 and ≤ 180 (was 0) @Size@Size 注解的作用是限定长度的，同上注解一样，可以修饰方法参数、方法返回值、成员属性。 限定字符串的长度：12public void setData(@Size(4) String data)&#123;&#125; 当传入的字符串长度不等于 4 时，编译器会直接报错：1Length must be exactly 4 限定数组的长度： 12public void setData(@Size(4) int[] data)&#123;&#125; 特殊的限定，如限定为 2 的倍数： 12public void setData(@Size(multiple = 2) int[] data)&#123;&#125; 限定最小的长度：1@Size(min = 2) 限定最大的长度：1@Size(max = 2) 等同于 @Size(2) 写法：1@Size(value = 2) @RequiresPermission该注解作用是表明方法所执行的内容需要权限。如需要单个权限：123@RequiresPermission(Manifest.permission.CALL_PHONE)private void callPhone(String phone)&#123;&#125; 需要一组权限：123456@RequiresPermission(allOf = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)public static final void copyFile(String dest, String source) &#123;...&#125; 对于 intent 权限，我们可以定义在 intent 操作名称的字符串上：123@RequiresPermission(android.Manifest.permission.BLUETOOTH)public static final String ACTION_REQUEST_DISCOVERABLE = \"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE\"; 对于需要单独读写权限的内容提供程序的权限，我们可以在 @RequiresPermission.Read 或 @RequiresPermission.Write 注解中包含每个权限要求：123@RequiresPermission.Read(@RequiresPermission(READ_HISTORY_BOOKMARKS))@RequiresPermission.Write(@RequiresPermission(WRITE_HISTORY_BOOKMARKS))public static final Uri BOOKMARKS_URI = Uri.parse(\"content://browser/bookmarks\"); 如果权限依赖于提供给方法参数的特定值，那么可以对参数本身使用 @RequiresPermission 而不用列出具体的权限，如 startActivity(intent) 方法：1public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle) &#123;...&#125; 当我们使用这种方式（间接权限）时，构建工具将执行数据流分析以检查传递到方法的参数是否具有任何 @RequiresPermission 注解。如：123Intent intent = new Intent(Intent.ACTION_CALL);intent.setData(Uri.parse(\"tel:1234567890\"));startActivity(intent); 这里的 startActivity(intent) 就直接报错了：1call requires permission which may be rejected by user: code should explicitly check to see if permission is available (with `checkPermission`) or explicitly handle a potential `SecurityException` 因为 Intent.ACTION_CALL 中标记了权限注解：123@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)@RequiresPermission(Manifest.permission.CALL_PHONE)public static final String ACTION_CALL = \"android.intent.action.CALL\"; @CheckResult@CheckResult 注解是作用于方法上的，作用是检验有没有处理返回值。如果没有处理返回值则会报错。1234@CheckResultpublic String getData(String data) &#123; return data.trim();&#125; 线程注解线程注解可以检查某个方法是否从特定类型的线程调用。支持以下线程注解： @MainThread：表示标记的方法只应在主线程调用。如果标记的是一个类，那么该类中的所有方法都应该是在主线程被调用。例：（通常，应用程序的主线程也是 Ui 线程。但是，在特殊情况下，应用程序的主线程可能不是其 Ui 线程） 12@MainThreadpublic void deliverResult(D data) &#123; ... &#125; @UiThread：表示标记的方法或构造函数只应该在 Ui 线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在 Ui 线程被调用。例： 12@UiThreadpublic abstract void setText(@NonNull String text) &#123;...&#125; @WorkerThread：表示标记的方法只应该在工作线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在一个工作线程上调用。例： 12@WorkerThreadprotected abstract FilterResults performFiltering(CharSequence constraint); @BinderThread：表示标记的方法只应在绑定线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在绑定线程被调用。例： 12@BinderThreadpublic BeamShareData createBeamShareData() &#123; ... &#125; @AnyThread：表示可以从任何线程调用带标记的方法。如果标记的是一个类，那么该类中的所有方法都可以从任何线程中调用。例： 12@AnyThreadpublic void deliverResult(D data) &#123; ... &#125; 构建工具会将 @MainThread 和 @UiThread 注解视为可以互换，因此，我们可以从 @MainThread 方法调用 @UiThread 方法，反之亦然。不过如果系统应用在不同线程上带有多个试图，Ui 线程可与主线程不同。因此，我们应该使用 @UiThread 标注于应用的视图层次结构关联的方法，使用 @MainThread 仅标注于应用生命周期关联的方法。 资源注解在 Android 中几乎所有的资源都有其对于的 id，我们在使用的时候可以直接通过 id 来，如：1textView.setText(getResources().getText(R.string.app_name)); 但是这样如果没有写指定的资源注解的话就会风险，比如随便传了个 0，那么就会找不到对应的资源。为了避免由于自己的粗心大意而引发的错误，我们就可以使用资源注解了，如：12public int getText(@StringRes int id)&#123;&#125; 这样当我们调用该方法时，如果传递的参数并不是 String 类型的资源 id，那么编译器就会报错提示。 除了 @StringRes 资源注解外，还有： @IntegerRes：R.integer 类型资源。 @AnimatorRes：R.animator 类型资源。 @AnimRes：R.anim 类型资源。 @ArrayRes：R.array 类型资源。 @AttrRes：R.attr 类型资源。 @BoolRes：R.bool 类型资源。 @ColorRes：R.color 类型资源。 @DimenRes：R.dimen 类型资源。 @DrawableRes：R.drawable 类型资源。 @FractionRes：R.fraction 类型资源。（百分比） @IdRes：R.id 类型资源。 @InterpolatorRes：R.interpolator 类型资源。（插值器） @LayoutRes：R.layout 类型资源。 @MenuRes：R.menu 类型资源。 @PluralsRes：R.plurals 类型资源。（复数） @RawRes：R.raw 类型资源。 @StyleableRes：R.styleable 类型资源。 @StyleRes：R.style 类型资源。 @TransitionRes： R.transition 类型资源。 @XmlRes：R.xml 类型资源。 @AnyRes：未知资源。（表示自己不知道是什么类型的资源。比如有可能为 R.drawable 也有可能是 R.string。） @ColorInt@ColorInt 注解的作用为：限定颜色值。（ARGB：0xAARRGGBB）123public void setColor(@ColorInt int color) &#123;&#125; 如果直接使用资源 id，则会报错，如下：1setColor(R.color.colorAccent)// 报错 正确的使用是：1setColor(0xFFFF00FF); 如果要使用资源 id，则可以通过 ContextCompat.getColor() 方法来：1setColor(ContextCompat.getColor(context, R.color.colorAccent)); @CallSuper该注解用于修饰方法，表示重写该方法时必须调用 super 方法。如 onCreate() 方法：123@CallSuperprotected void onCreate(Bundle savedInstanceState) &#123;&#125; 重写 onCreate() 方法时，必须调用 super 方法：1super.onCreate(savedInstanceState); 否则报错。 @VisibleForTesting &amp; @Keep使用 @VisibleForTesting 和 @Keep 注解可以表示方法、类、或字段的可访问性。 @VisibleForTesting：该注解只起到一个注释的作用，告诉其他开发者被标记的代码为什么有这么大的可见程度（为了测试方便）。因此，经常用来修饰 public 或 protected，用来修饰 private 并不会报错，但是没有意义。 @Keep：标记的指定代码在混淆时不会被混淆。 参考： https://developer.android.com/studio/write/annotations.html?hl=zh-cn http://droidyue.com/blog/2016/08/14/android-annnotation/","categories":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://airsaid.github.io/tags/Android/"},{"name":"注解","slug":"注解","permalink":"http://airsaid.github.io/tags/注解/"},{"name":"代码优化","slug":"代码优化","permalink":"http://airsaid.github.io/tags/代码优化/"}]},{"title":"Java 8 中接口的默认方法与静态方法","slug":"Java8-Interface-DefaultMethod-StaticMethod","date":"2018-02-01T07:48:19.000Z","updated":"2018-04-22T13:50:56.133Z","comments":true,"path":"20180201/Java8-Interface-DefaultMethod-StaticMethod/","link":"","permalink":"http://airsaid.github.io/20180201/Java8-Interface-DefaultMethod-StaticMethod/","excerpt":"在 Java 8 中，接口引入了一些新的语言特性：默认方法（Default Methods）以及静态方法（Static Methods）。本篇文章就来了解下这两个特性。","text":"在 Java 8 中，接口引入了一些新的语言特性：默认方法（Default Methods）以及静态方法（Static Methods）。本篇文章就来了解下这两个特性。 默认方法默认方法的定义默认方法的定义需要用到 default 关键字，例如：12345public interface A &#123; default String getName()&#123; return \"A\"; &#125;&#125; 默认方法不可以被 private 修饰，默认就是 public 的，public 可以省略不写。 默认方法的使用当有类实现了该接口后，可以直接调用该默认方法，例如：123public class C implements A&#123; &#125; 12345public class Main&#123; public static void main(String[] args) &#123; System.out.println(new C().getName());// A &#125;&#125; 同时，在具体的接口实现类中也可以对接口中的默认方法进行覆写。例如：123456public class C implements A&#123; @Override public String getName() &#123; return \"C\"; &#125;&#125; 12345public class Main&#123; public static void main(String[] args) &#123; System.out.println(new C().getName());// C &#125;&#125; 默认方法的继承大家都知道，接口与接口之间是可以继承的。那么在有默认方法的情况下，接口的继承又是什么样子的呢？我们来看看下面的继承例子：12345public interface A &#123; default String getName()&#123; return \"A\"; &#125;&#125; 123public interface B extends A&#123;&#125; 123456public interface C extends B&#123; @Override default String getName() &#123; return \"C\"; &#125;&#125; 1234public interface D extends C&#123; @Override String getName();&#125; 12345678910111213public class Main&#123; public static void main(String[] args) &#123; System.out.println(new A()&#123;&#125;.getName());// A System.out.println(new B()&#123;&#125;.getName());// A System.out.println(new C()&#123;&#125;.getName());// C System.out.println(new D()&#123; @Override public String getName() &#123; return \"D\"; &#125; &#125;.getName());// D &#125;&#125; 通过打印结果，我们可以发现其继承关系有这么几种情况： 不覆写父接口的默认方法，直接用父接口的方法实现。（参考 B 接口） 覆写父接口的默认方法，用自己的实现。（参考 C 接口） 覆写父接口的默认方法实现，并将其更改为抽象方法。（参考 D 接口） 前两个很好理解，就跟类的继承是一样的。第三个呢，当把默认方法改为抽象方法后，那么实现类就必须去实现该抽象方法了。 为什么要有默认方法想象一个场景，假如在没有默认方法的情况下我们需要对集合框架增加一个新的迭代功能（forEach），那么我们就需要对其 Iterable 接口增加一个新的抽象方法，但是这样做的后果就是该接口下的所有实现类都必须去实现该方法。可是由于集合框架体系的庞大，实现类有非常多个，一改动全身，影响实在是太大，并不可取。 但是当有默认方法时，就解决了这个问题，就算在接口中增加了新的默认方法，具体的实现类也无需改动就有了新功能。 默认方法的出现就是为了保证原有代码兼容性的同时在接口中增加新的功能。 默认方法带来的问题默认方法虽好，但是我们也不可以滥用。因为默认方法会在复杂的继承关系中给我们的程序带来歧义以及编译错误。 由于接口是可以被多继承的，所以我们来看下面这种情况：12345public interface A &#123; default String getName()&#123; return \"A\"; &#125;&#125; 12345public interface B &#123; default String getName()&#123; return \"B\"; &#125;&#125; 123public class C implements A, B&#123;&#125; 当 C 类同时实现 A、B 接口时，编译是无法通过的。很明显，因为 A、B 接口中都有 getName() 方法，要是能编译通过的话，程序怎么会知道调用哪个呢？所以出现这种情况，C 类必须去覆写 getName() 方法，然后给出自己的想要的 “结果”，例如，用 A 的 “结果”：1234@Overridepublic String getName() &#123; return A.super.getName();&#125; 或者说是自己给一个 “结果”：1234@Overridepublic String getName() &#123; return \"C\";&#125; 当最终调用的时候，打印结果就是：A、C 了。 另外还有一种稍复杂的情况，来看下这个例子：12345public interface A &#123; default String getName()&#123; return \"A\"; &#125;&#125; 123456public interface B extends A&#123; @Override default String getName() &#123; return \"B\"; &#125;&#125; 12345678910111213141516171819public class Main&#123; static class C implements A, B&#123; &#125; static class D implements A, B&#123; @Override public String getName() &#123;// return A.super.getName();// 报错 return B.super.getName();// 正确 &#125; &#125; public static void main(String[] args) &#123; System.out.println(new C().getName());// B System.out.println(new D().getName());// B &#125;&#125; C 这个类同时实现了 A 、B 接口，怎么就不报错让其实现 getName() 方法了呢？仔细看，B 和 A 是继承的关系。当 B 继承 A 后并覆写了 getName() 方法，那么 A 的 getName() 其实已经被屏蔽了。当同时实现这两个接口时，打印出的自然是 B 的 “结果” 了。同理，D 类中不可用 A 接口的实现也是如此。 这是当接口继承行为发生冲突时的规则之一，即 被其他类型所覆盖的方法会被忽略。 但是，我们就是想要 A 接口的结果，这怎么办？我们可以来新定义一个接口来解决该问题：12345public interface A &#123; default String getName()&#123; return \"A\"; &#125;&#125; 123456public interface B extends A&#123; @Override default String getName() &#123; return \"B\"; &#125;&#125; 123456public interface C extends A&#123; @Override default String getName() &#123; return A.super.getName();// 注意，这里必须去调用 A 接口的实现 &#125;&#125; 12345678910111213public class Main&#123; static class D implements B, C&#123; @Override public String getName() &#123; return C.super.getName(); &#125; &#125; public static void main(String[] args) &#123; System.out.println(new D().getName());// A &#125;&#125; 绕了一圈，总算是得到 A 的结果了。在该例子中，我们需要注意的是，在新定义的接口中，必须去调用 A 接口的实现，如果不调用的话，A 接口中的 getName() 方法依然会被 B 接口覆写导致屏蔽。切记切记！ 默认方法总结默认方法给予我们修改接口并且不破坏原有实现类提供了便利。但是同时也带来了一些问题，比如上文中提到了继承冲突。以及接口与类的关系由约束及实现而变得更加模糊。因此，我们应该在定义默认方法之前思考下是否真的必须这样做。 静态方法从 Java 8 开始，接口除了可以定义默认方法外，还可以定义静态方法。 接口中静态方法的定义和类中的定义差不多：12345public interface A &#123; static void print()&#123; System.out.println(\"A\"); &#125;; &#125; 只不过在接口中，默认是由 public 所修饰的，并且同默认方法一样，是不可以更改为 private 的。 调用时，直接接口名.方法名：1A.print();","categories":[{"name":"Java","slug":"Java","permalink":"http://airsaid.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://airsaid.github.io/tags/Java/"},{"name":"Java 8","slug":"Java-8","permalink":"http://airsaid.github.io/tags/Java-8/"}]}]}