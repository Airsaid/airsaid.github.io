<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Airsaid&#39;s Blog</title>
  
  <subtitle>为写出优雅的代码而努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://airsaid.github.io/"/>
  <updated>2018-02-05T13:21:35.160Z</updated>
  <id>http://airsaid.github.io/</id>
  
  <author>
    <name>Airsaid</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 约束布局（ConstraintLayout）详解</title>
    <link href="http://airsaid.github.io/20180205/Android-ConstraintLayout-Detailed/"/>
    <id>http://airsaid.github.io/20180205/Android-ConstraintLayout-Detailed/</id>
    <published>2018-02-05T03:32:48.000Z</published>
    <updated>2018-02-05T13:21:35.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇 ConstraintLayout 讲解版本：1.0.2，1.1.x 版本开始新增功能在下篇进行讲解</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ConstraintLayout 是一个 ViewGroup，它的出现是为了解决复杂布局时，布局嵌套（布局内的布局）过多的问题（嵌套布局会增加绘制界面所需的时间）。它可以根据同级视图和父布局的约束条件为每个视图定义位置，类似于 RelativeLayout 所有视图都是根据兄弟视图和父级布局之间的关系来布局的，但是与 RelativeLayout 相比，它更加灵活，更易于使用。</p><p>在 Android 2.2 的版本中，为了给 ConstraintLayout 提供支持，Android 设计了新的布局编辑器。我们可以直接在布局编辑器当中拖动控件、添加约束，一气呵成。当然，在布局编辑器当中所做的操作，XML 布局当中就会自动生成对应的属性。</p><p>其中生成的一些属性，有可能并不是必须需要的。所以在生成后，你可能还需要手动检查、清理一下。或者你也可以直接在 XML 中编写属性，ConstraintLayout 的属性虽多，但是都是成组的，还是很容易掌握的。</p><h2 id="约束概述"><a href="#约束概述" class="headerlink" title="约束概述"></a>约束概述</h2><p>要在 ConstraintLayout 中定义 View 的位置，必须为该 View 添加至少一个水平和垂直约束（否则该 View 就会在左上角绘制）。该约束对象可以是另一个视图，或者父布局（也就是 ConstraintLayout），或者是不可见的 Guideline（后面会讲 Guideling）等。</p><p>如果有缺少的约束（或其他的一些优化问题），编辑器会在右上角显示警告提示（编译器不会错误）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="警告提示.png" alt="警告提示（提示有 5 处可修复和优化的地方）" title="">                </div>                <div class="image-caption">警告提示（提示有 5 处可修复和优化的地方）</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="正常情况.png" alt="正常情况" title="">                </div>                <div class="image-caption">正常情况</div>            </figure><h2 id="转换布局"><a href="#转换布局" class="headerlink" title="转换布局"></a>转换布局</h2><p>如果要将现有布局转换为约束布局，只需按照下列步骤操作：</p><ol><li><p>在 Android Studio 中打开布局，然后单击编辑器窗口底部的 Design 选项卡。</p></li><li><p>在 Component Tree 窗口中，右键单击布局，然后单击 Convert layout to ConstraintLayout。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="转换代码.png" alt="转换布局" title="">                </div>                <div class="image-caption">转换布局</div>            </figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>要在项目中使用 ConstraintLayout，我们需要在 build.gradle 中添加依赖（新版 AndroidStudio 会默认添加）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.android.support.constraint:constraint-layout:1.0.2'</span></span><br></pre></td></tr></table></figure><p>然后，在工具栏中同步 Gradle 文件。</p><h2 id="创建布局"><a href="#创建布局" class="headerlink" title="创建布局"></a>创建布局</h2><p>接下来，我们创建一个布局，根布局就用 ConstraintLayout：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h2><p>添加约束十分简单，我们首先从 Design 界面的 Palette 操作栏拖动一个 Button 到蓝图中，添加完后，点击选中它，效果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="蓝图效果.png" alt="蓝图效果" title="">                </div>                <div class="image-caption">蓝图效果</div>            </figure><p>可以看到，上下左右都有一个小圆圈，这个圆圈就是用来添加约束的。</p><p>四个角的矩形，是用来扩大或缩小控件的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="删除该控件上所有约束.png" alt="删除该控件上所有约束" title="">                </div>                <div class="image-caption">删除该控件上所有约束</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="编辑基线.png" alt="编辑基线，用于基线对齐（下面会说）" title="">                </div>                <div class="image-caption">编辑基线，用于基线对齐（下面会说）</div>            </figure><p>现在我们来为这个 Button 添加约束：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="添加约束.gif" alt="添加约束（约束对象为父控件）" title="">                </div>                <div class="image-caption">添加约束（约束对象为父控件）</div>            </figure><p>看这个效果，有没有一种「四马分尸」的感觉？当只有一条边拉这个 Button 时，Button 马上就被拉过去了，但是当四个边都开始拉这个 Button 时，Button 就在中间动弹不得了。</p><p>看完了动图，我们再来看看 XML 布局中的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/button"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"Button"</span></span><br><span class="line">    app:layout_constraintTop_toTopOf=<span class="string">"parent"</span></span><br><span class="line">    android:layout_marginTop=<span class="string">"8dp"</span></span><br><span class="line">    android:layout_marginLeft=<span class="string">"8dp"</span></span><br><span class="line">    app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br><span class="line">    android:layout_marginRight=<span class="string">"8dp"</span></span><br><span class="line">    app:layout_constraintRight_toRightOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">    android:layout_marginBottom=<span class="string">"8dp"</span>/&gt;</span><br></pre></td></tr></table></figure><p>因为我们的目的是想让这个 Button 居中，但是它却默认给我们添加了 margin，这个显然是多余的。</p><p>如果不想每次添加约束后都在这条边的约束上添加 margin，我们可以在上面的工具栏中进行设置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="设置默认margin.png" alt="设置控件默认的 margin" title="">                </div>                <div class="image-caption">设置控件默认的 margin</div>            </figure><p>抛去 margin 相关的属性，那么约束父控件的相关属性就是如下这些了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintTop_toTopOf=<span class="string">"parent"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintRight_toRightOf=<span class="string">"parent"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br></pre></td></tr></table></figure><p>在上面的图中我们已经看到了，每个控件的上下左右都有一个圆圈，用于添加约束的。</p><p>那么这些属性的 constraintXXX 就是指定的当前控件的约束位置的，而 toXXX 就是目标约束位置。</p><p>这个位置可以是上面的例子一样是 parent（也就是父控件），也可以是另一个控件。</p><p>接下来我们再来看看对于其他控件的约束。</p><p>再拖一个 Buttton 进入蓝图中，然后给这个 Button 添加约束：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="添加约束（约束对象为另一个控件）.gif" alt="添加约束（约束对象为另一个控件）" title="">                </div>                <div class="image-caption">添加约束（约束对象为另一个控件）</div>            </figure><p>XML 布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Button    </span><br><span class="line">android:id=<span class="string">"@+id/button2"</span>    </span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span>    </span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>    </span><br><span class="line">android:text=<span class="string">"Button"</span>    </span><br><span class="line">app:layout_constraintLeft_toLeftOf=<span class="string">"@+id/button"</span>    </span><br><span class="line">app:layout_constraintRight_toRightOf=<span class="string">"@+id/button"</span>    </span><br><span class="line">android:layout_marginTop=<span class="string">"48dp"</span>    </span><br><span class="line">app:layout_constraintTop_toBottomOf=<span class="string">"@+id/button"</span>/&gt;</span><br></pre></td></tr></table></figure><p>添加完约束了，如果要删除指定的单个约束的话，单击变红的圆圈即可：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="删除指定的单个约束.gif" alt="删除指定的单个约束" title="">                </div>                <div class="image-caption">删除指定的单个约束</div>            </figure><p>或者是上面提到了，删除指定控件的所有约束。</p><p>或者是工具栏中的，删除页面所有的约束：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="删除页面所有的约束.png" alt="删除页面所有的约束" title="">                </div>                <div class="image-caption">删除页面所有的约束</div>            </figure><h2 id="基线约束"><a href="#基线约束" class="headerlink" title="基线约束"></a>基线约束</h2><p>基线约束的作用就是将视图的文本基线与另一个视图的文本基线对齐：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="添加基线约束.gif" alt="添加基线约束" title="">                </div>                <div class="image-caption">添加基线约束</div>            </figure><p>添加完成后，在 XML 布局中，B 控件就会多出这么一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintBaseline_toBaselineOf=<span class="string">"@+id/a"</span></span><br></pre></td></tr></table></figure><p>该属性就是用于基线对齐的。</p><h2 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h2><p>Chains（链）是一种特定的约束，一个链包含了多个视图，它允许链中的视图共享空间，并控制可用空间在它们之间如何分配。该效果与 LinearLayout 的 Weiget 类似，但是链的作用远远超过它。</p><p>我们要是想创建一个链，那么首先就需要创建多个视图控件，然后再选择是创建「水平链」还是「垂直链」。</p><p>让我们从三个视图中创建一个「水平链」：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="创建「水平链」.gif" alt="创建「水平链」" title="">                </div>                <div class="image-caption">创建「水平链」</div>            </figure><p>「垂直链」：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="创建「垂直链」.gif" alt="创建「垂直链」" title="">                </div>                <div class="image-caption">创建「垂直链」</div>            </figure><p>以「水平链」为例，我们来看看它们的样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="「水平链」.png" alt="「水平链」" title="">                </div>                <div class="image-caption">「水平链」</div>            </figure><p>可以发现，两侧控件的约束样子和前面约束的样子是一样的，我把它称之为「单约束」，也就是两侧控件只是单方面的约束了对方（这里是父控件）。</p><p>而中间的控件，两侧的约束则是链条的样子，这表示它约束了左右侧控件，而左右侧控件同样也约束了它：「互相约束」。</p><p>在 XML 布局中，是通过如下属性实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"Button"</span></span><br><span class="line">    app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintRight_toLeftOf=<span class="string">"@+id/button2"</span></span><br><span class="line">    tools:layout_editor_absoluteY=<span class="string">"69dp"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"Button"</span></span><br><span class="line">    app:layout_constraintLeft_toRightOf=<span class="string">"@+id/button1"</span></span><br><span class="line">    app:layout_constraintRight_toLeftOf=<span class="string">"@+id/button3"</span></span><br><span class="line">    tools:layout_editor_absoluteY=<span class="string">"69dp"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"Button"</span></span><br><span class="line">    app:layout_constraintLeft_toRightOf=<span class="string">"@+id/button2"</span></span><br><span class="line">    app:layout_constraintRight_toRightOf=<span class="string">"parent"</span></span><br><span class="line">    tools:layout_editor_absoluteY=<span class="string">"69dp"</span>/&gt;</span><br></pre></td></tr></table></figure><p>我们刚刚创建好了一条链，此时我们可以设置 Cycle Chain Mode（链式模式）来告诉 Chains：“你应该怎样去填充剩余的空间”。</p><p>在「蓝图」中，设置的方式是点击链条的小图标：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="多出来了链条图标.png" alt="多出来了链条图标" title="">                </div>                <div class="image-caption">多出来了链条图标</div>            </figure><p>在「布局」中，设置的属性是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintVertical_chainStyle</span><br></pre></td></tr></table></figure><p>分别对应着「水平链」和「垂直链」。</p><p>有三种可选的参数：</p><ul><li><p>spread：将可用空间以均匀分布的方式将视图放置在链中（默认模式）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="spread.png" alt="spread" title="">                </div>                <div class="image-caption">spread</div>            </figure></li><li><p>spread_inside：将链中最外面的视图对齐到外边缘，然后在可用空间内均匀的放置链中的其他视图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="spread_inside.png" alt="spread_inside" title="">                </div>                <div class="image-caption">spread_inside</div>            </figure></li><li><p>packed：将链中的视图紧紧的放在一起（可以提供边距让其分开），然后让其居中在可用空间内：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="packed.png" alt="packed" title="">                </div>                <div class="image-caption">packed</div>            </figure></li></ul><p>除了上面说的之外，Chains 还能对链中单独的视图控件设置 Weiget。因为目前并不支持在编辑器当中设置 Weiget，所以我们只能在布局中进行设置了，设置的属性是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_weight</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintVertical_weight</span><br></pre></td></tr></table></figure><p>我们现在将第一个 Button 填充完剩余的空间，在该 Buttton 上设置如下属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintHorizontal_weight=<span class="string">"1"</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="weight.png" alt="weight 效果" title="">                </div>                <div class="image-caption">weight 效果</div>            </figure><p>使用和 LinearLayout 的 Weiget 一致，很好理解。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>基本的添加、删除约束我们已经掌握了，那么现在再来将目光转向右侧的 Properties 区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Properties.png" alt="Properties" title="">                </div>                <div class="image-caption">Properties</div>            </figure><p>该区域分为了上下两个部分，下部分就是选中控件的一些属性什么的，很好理解。</p><p>重点来看看上半部分，该部分被称为：Inspector 区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Inspector.png" alt="Inspector" title="">                </div>                <div class="image-caption">Inspector</div>            </figure><p>首先来看这些数字，很明显就是当前控件的 margin 值，我们可以直接在上面进行修改：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="修改控件的margin.png" alt="修改控件的 margin" title="">                </div>                <div class="image-caption">修改控件的 margin</div>            </figure><p>还有就是左边和下边的两个轴，我把它称之为纵横轴。作用是用于确定控件位置的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="修改纵横轴.gif" alt="修改纵横轴" title="">                </div>                <div class="image-caption">修改纵横轴</div>            </figure><p>根据上图可以看到，因为该控件同时添加了水平和垂直约束，所以两条轴都可以进行操作。</p><p>轴上面的数字是比例，对应的属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintVertical_bias=&quot;0.5&quot;</span><br><span class="line">app:layout_constraintHorizontal_bias=&quot;0.5&quot;</span><br></pre></td></tr></table></figure><p>再来看看中心区域：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Inspector中心区域.png" alt="Inspector 中心区域" title="">                </div>                <div class="image-caption">Inspector 中心区域</div>            </figure><p>四条边的原点就是添加的约束，点击的作用是删除该约束。</p><p>重要的是中心的 &lt;&lt;&lt;，这个代表了当前控件的宽高计算方式。点击是可以切换的，一共有三种：</p><ul><li><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src=">>>.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>：这个代表的就是 wrap_content，不用过多解释了。</p></li><li><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="指定大小.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>：这个就是指定宽高的大小。</p></li><li><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="MatchConstraints.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>：这个代表的是：Match Constraints（有点类似于 match_parent），就给强翻成约束匹配吧… 这个是 ConstraintLayout 特有的，它会尽可能扩展以满足各方的约束（在考虑视图边界之后）。但是，可以使用以下属性和值修改该行为（只有在将视图宽度设置为与约束匹配时，这些属性才会生效）：</p><ul><li>layout_constraintWidth_default：<ul><li>spread：这是默认的行为，它会尽可能的扩展视图来满足约束。</li><li>wrap：与上面所说的 wrap_content 不同的是，虽然都是适应内容，但仍然允许视图比约束要求的视图更小。</li><li>layout_constraintWidth_min：指定视图的最小宽度（dp）。<br>​        - layout_constraintWidth_max：指定视图的最大宽度（dp）。</li></ul></li></ul></li></ul><p>下面来几个例子，演示下约束匹配的效果，比如说，要让一个 Button 宽度填充满，仅需要将宽度设置为 0dp 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br></pre></td></tr></table></figure><p>如果是两个 Button：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button    </span><br><span class="line">android:id=<span class="string">"@+id/button1"</span>    </span><br><span class="line">android:layout_width=<span class="string">"0dp"</span>    </span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>    </span><br><span class="line">android:text=<span class="string">"A"</span>    </span><br><span class="line">app:layout_constraintTop_toTopOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintRight_toRightOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button    </span><br><span class="line">android:id=<span class="string">"@+id/button2"</span>    </span><br><span class="line">android:layout_width=<span class="string">"0dp"</span>    </span><br><span class="line">android:layout_height=<span class="string">"0dp"</span>    </span><br><span class="line">android:text=<span class="string">"B"</span>    </span><br><span class="line">app:layout_constraintTop_toBottomOf=<span class="string">"@+id/button1"</span>    </span><br><span class="line">app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintRight_toRightOf=<span class="string">"parent"</span>/&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="约束匹配效果.png" alt="约束匹配效果" title="">                </div>                <div class="image-caption">约束匹配效果</div>            </figure><h2 id="设置宽高比例"><a href="#设置宽高比例" class="headerlink" title="设置宽高比例"></a>设置宽高比例</h2><p>当宽高至少有一项设置为 0dp 时（也就是 Match Constraints），那么我们就可以为该视图设置宽高比例。设置的属性是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintDimensionRatio</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button    </span><br><span class="line">android:id=<span class="string">"@+id/button"</span>    </span><br><span class="line">android:layout_width=<span class="string">"0dp"</span>    </span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>    </span><br><span class="line">android:text=<span class="string">"button"</span>    </span><br><span class="line">app:layout_constraintDimensionRatio=<span class="string">"3:1"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="设置宽高比.png" alt="设置宽高比" title="">                </div>                <div class="image-caption">设置宽高比</div>            </figure><p>参数是一个浮点值：“宽度：高度”，在该例子中，表示的宽高比是 3:1，也就是高度是宽度的三分之一。</p><p>当我们的宽高都设置为 0dp 时，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buttona</span><br><span class="line">android:id=<span class="string">"@+id/button"</span>    </span><br><span class="line">android:layout_width=<span class="string">"0dp"</span>    </span><br><span class="line">android:layout_height=<span class="string">"0dp"</span>    </span><br><span class="line">android:text=<span class="string">"button"</span>    </span><br><span class="line">app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span>    </span><br><span class="line">app:layout_constraintRight_toRightOf=<span class="string">"parent"</span>/&gt;</span><br></pre></td></tr></table></figure><p>此时，该视图是不会显示的，虽然我们加了 left 和 rigth 约束到父控件，让它知道了它的宽度就是父控件的高度，但是此时它还并不知道自己有多高。<br>所以此时我们在添加 ration 时，则可以指示哪一方应该受到约束，方法是在比率前面添加字母 W（用于限制宽度）或 H（用于限制高度），用逗号分隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintDimensionRatio=<span class="string">"h, 3:1"</span></span><br></pre></td></tr></table></figure><p>这里设置的宽高比例是 3:1，那么高度就只有宽度的三分之一了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="设置宽高比2.png" alt="设置宽高比" title="">                </div>                <div class="image-caption">设置宽高比</div>            </figure><h2 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h2><p>Guidelines 是一条对实际显示界面不可见的线。用处是帮助我们的控件增加约束。</p><p>我们可以通过该图标来添加垂直或者水平的 Guidelines：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="添加Guideline.png" alt="添加 Guideline" title="">                </div>                <div class="image-caption">添加 Guideline</div>            </figure><p>比如我们想让控件在中心显示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Guideline.gif" alt="Guideline 演示" title="">                </div>                <div class="image-caption">Guideline 演示</div>            </figure><p>可以看到 Guidelines 可以切换百分比，或者是实际的距离。具体用哪种还是得根据实际情况来。</p><h2 id="自动添加约束"><a href="#自动添加约束" class="headerlink" title="自动添加约束"></a>自动添加约束</h2><p>有两种方式实现自动添加约束，分别是：</p><ul><li>Autoconnect：这是一个独立的功能，默认是关闭的。我们可以开启它，开启后，它将自动为新添加的视图创建两个或者更多的约束。其他的视图则不会自动添加，如：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Autoconnect.gif" alt="Autoconnect" title="">                </div>                <div class="image-caption">Autoconnect</div>            </figure><ul><li>Infer Constraints：为当前所有的视图自动添加约束：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="InferConstraints.gif" alt="Infer Constraints" title="">                </div>                <div class="image-caption">Infer Constraints</div>            </figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://developer.android.com/training/constraint-layout/index.html?hl=zh-cn#add-constraintlayout-to-your-project" target="_blank" rel="noopener">https://developer.android.com/training/constraint-layout/index.html?hl=zh-cn#add-constraintlayout-to-your-project</a></p></li><li><p><a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html</a></p></li><li><p><a href="https://constraintlayout.com/" target="_blank" rel="noopener">https://constraintlayout.com/</a></p></li><li><p><a href="http://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/53122387</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇 ConstraintLayout 讲解版本：1.0.2，1.1.x 版本开始新增功能在下篇进行讲解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://airsaid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://airsaid.github.io/tags/Android/"/>
    
      <category term="ConstraintLayout" scheme="http://airsaid.github.io/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>使用 Android Support Annotations 库来优化你的代码</title>
    <link href="http://airsaid.github.io/20180202/Use-Android-Support-Annotations-library-optimize-code/"/>
    <id>http://airsaid.github.io/20180202/Use-Android-Support-Annotations-library-optimize-code/</id>
    <published>2018-02-02T09:48:00.000Z</published>
    <updated>2018-02-05T13:21:35.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Support Library 从 19.1 版本开始引入了一个新的注解库（Android Support Annotations Library），其中包含了很多的元注解，使用它们修饰我们的代码， 可以让我们提高程序的开发效率，让我们更早的发现问题。以及对代码施以规范，让代码更加有可读性。这篇文章就来简单了解下这些注解，以及其使用。如有错误和遗漏，欢迎留言和补充～</p></blockquote><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在 build.gradle 中添加依赖库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.android.support:support-annotations:22.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：在新版本的 AndroidStudio 下，新建的项目就直接依赖了 support.appcompat 包，而其中已经有了 annotations 包，所以不必重复添加。如果你在使用下面的注解时发现找不到对应的注解，那么再按照如上步骤添加依赖库即可。</p></blockquote><h2 id="IntDef-amp-StringDef"><a href="#IntDef-amp-StringDef" class="headerlink" title="@IntDef &amp; @StringDef"></a>@IntDef &amp; @StringDef</h2><p>替代 Java 中枚举的注解，以 @IntDef 为例，定义和使用如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntDef</span>(&#123;RED, BLUE, YELLOW&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LightColors&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLUE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> YELLOW = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@LightColors <span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>@interface：声明新的枚举注解类型。</li><li>@Retention(RetentionPolicy.SOURCE)：告知编译器不将枚举的注解数据存储在 .class 文件中。</li></ul><p>如果允许常量与标志（例如：|、&amp; 和 ^ 等等）相结合，则我们可以使用 flag 属性，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntDef</span>(flag = <span class="keyword">true</span>, value = &#123;RED, BLUE, YELLOW&#125;)</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setColor(RED | BLUE);</span><br></pre></td></tr></table></figure></p><h2 id="Nullable-amp-NonNull"><a href="#Nullable-amp-NonNull" class="headerlink" title="@Nullable &amp; @NonNull"></a>@Nullable &amp; @NonNull</h2><ul><li>@Nullable：注解的元素可以为 null。</li><li>@NonNull：注解的元素不可以为 null。</li></ul><p>上面的注解可以修饰如下元素：<br>1，方法参数。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String data;</span><br></pre></td></tr></table></figure></p><p>2，方法的返回值。 如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3，成员属性。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(@Nullable String data)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用空的参数传给被 @NonNull 修饰的方法参数的方法时，会给出如下警告提示（编译不会报错）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passing <span class="string">"null"</span> argument to parameter annotated as <span class="meta">@NotNull</span></span><br></pre></td></tr></table></figure></p><h2 id="FloatRange-amp-IntRange"><a href="#FloatRange-amp-IntRange" class="headerlink" title="@FloatRange &amp; @IntRange"></a>@FloatRange &amp; @IntRange</h2><p>@FloatRange 和 @IntRange 是用于限定范围的注解。其中 @FloatRange 是限定 float 类型的，而 @IntRange 是限定 int 类型的。它们同上注解一样，可以修饰方法参数、方法返回值、成员属性。</p><p>以 @IntRange 为例，修饰方法参数的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(@IntRange(from = <span class="number">1</span>, to = <span class="number">180</span>)</span> <span class="keyword">int</span> age)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果调用该方法传的参数不在 1 - 180 的范围内， 如：setAge(0)，那么编译会直接报如下错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value must be ≥ <span class="number">1</span> and ≤ <span class="number">180</span> (was <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Size"><a href="#Size" class="headerlink" title="@Size"></a>@Size</h2><p>@Size 注解的作用是限定长度的，同上注解一样，可以修饰方法参数、方法返回值、成员属性。</p><ul><li>限定字符串的长度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(@Size(<span class="number">4</span>)</span> String data)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当传入的字符串长度不等于 4  时，编译器会直接报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length must be exactly <span class="number">4</span></span><br></pre></td></tr></table></figure></p><ul><li><p>限定数组的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(@Size(<span class="number">4</span>)</span> <span class="keyword">int</span>[] data)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊的限定，如限定为 2 的倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(@Size(multiple = <span class="number">2</span>)</span> <span class="keyword">int</span>[] data)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>限定最小的长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Size</span>(min = <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>限定最大的长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Size</span>(max = <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>等同于 @Size(2) 写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Size</span>(value = <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h2 id="RequiresPermission"><a href="#RequiresPermission" class="headerlink" title="@RequiresPermission"></a>@RequiresPermission</h2><p>该注解作用是表明方法所执行的内容需要权限。如需要单个权限：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.CALL_PHONE)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">(String phone)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要一组权限：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(allOf = &#123;</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String dest, String source)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 intent 权限，我们可以定义在 intent 操作名称的字符串上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.BLUETOOTH)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_REQUEST_DISCOVERABLE =</span><br><span class="line">        <span class="string">"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"</span>;</span><br></pre></td></tr></table></figure></p><p>对于需要单独读写权限的内容提供程序的权限，我们可以在 @RequiresPermission.Read 或 @RequiresPermission.Write 注解中包含每个权限要求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>.Read(<span class="meta">@RequiresPermission</span>(READ_HISTORY_BOOKMARKS))</span><br><span class="line"><span class="meta">@RequiresPermission</span>.Write(<span class="meta">@RequiresPermission</span>(WRITE_HISTORY_BOOKMARKS))</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOKMARKS_URI = Uri.parse(<span class="string">"content://browser/bookmarks"</span>);</span><br></pre></td></tr></table></figure></p><p>如果权限依赖于提供给方法参数的特定值，那么可以对参数本身使用 @RequiresPermission 而不用列出具体的权限，如 startActivity(intent) 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(@RequiresPermission Intent intent, @Nullable Bundle)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>当我们使用这种方式（间接权限）时，构建工具将执行数据流分析以检查传递到方法的参数是否具有任何 @RequiresPermission  注解。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"tel:1234567890"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>这里的 startActivity(intent) 就直接报错了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call <span class="keyword">requires</span> permission which may be rejected by user: <span class="function">code should explicitly check to see <span class="keyword">if</span> permission is <span class="title">available</span> <span class="params">(with `checkPermission`)</span> or explicitly handle a potential `SecurityException`</span></span><br></pre></td></tr></table></figure></p><p>因为  Intent.ACTION_CALL 中标记了权限注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SdkConstant</span>(SdkConstantType.ACTIVITY_INTENT_ACTION)</span><br><span class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.CALL_PHONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_CALL = <span class="string">"android.intent.action.CALL"</span>;</span><br></pre></td></tr></table></figure></p><h2 id="CheckResult"><a href="#CheckResult" class="headerlink" title="@CheckResult"></a>@CheckResult</h2><p>@CheckResult 注解是作用于方法上的，作用是检验有没有处理返回值。如果没有处理返回值则会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程注解"><a href="#线程注解" class="headerlink" title="线程注解"></a>线程注解</h2><p>线程注解可以检查某个方法是否从特定类型的线程调用。支持以下线程注解：</p><ul><li><p>@MainThread：表示标记的方法只应在主线程调用。如果标记的是一个类，那么该类中的所有方法都应该是在主线程被调用。例：（通常，应用程序的主线程也是 Ui 线程。但是，在特殊情况下，应用程序的主线程可能不是其 Ui 线程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(D data)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>@UiThread：表示标记的方法或构造函数只应该在  Ui 线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在 Ui 线程被调用。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(@NonNull String text)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>@WorkerThread：表示标记的方法只应该在工作线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在一个工作线程上调用。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> FilterResults <span class="title">performFiltering</span><span class="params">(CharSequence constraint)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>@BinderThread：表示标记的方法只应在绑定线程上调用。如果标记的是一个类，那么该类中的所有方法都应是在绑定线程被调用。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BinderThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeamShareData <span class="title">createBeamShareData</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>@AnyThread：表示可以从任何线程调用带标记的方法。如果标记的是一个类，那么该类中的所有方法都可以从任何线程中调用。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnyThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(D data)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>构建工具会将 @MainThread 和 @UiThread 注解视为可以互换，因此，我们可以从 @MainThread 方法调用 @UiThread 方法，反之亦然。不过如果系统应用在不同线程上带有多个试图，Ui 线程可与主线程不同。因此，我们应该使用 @UiThread 标注于应用的视图层次结构关联的方法，使用 @MainThread 仅标注于应用生命周期关联的方法。</p></blockquote><h2 id="资源注解"><a href="#资源注解" class="headerlink" title="资源注解"></a>资源注解</h2><p>在 Android 中几乎所有的资源都有其对于的 id，我们在使用的时候可以直接通过 id 来，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(getResources().getText(R.string.app_name));</span><br></pre></td></tr></table></figure></p><p>但是这样如果没有写指定的资源注解的话就会风险，比如随便传了个 0，那么就会找不到对应的资源。<br>为了避免由于自己的粗心大意而引发的错误，我们就可以使用资源注解了，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getText</span><span class="params">(@StringRes <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当我们调用该方法时，如果传递的参数并不是 String 类型的资源 id，那么编译器就会报错提示。</p><p>除了 @StringRes 资源注解外，还有：</p><ul><li>@IntegerRes：R.integer 类型资源。</li><li>@AnimatorRes：R.animator 类型资源。</li><li>@AnimRes：R.anim 类型资源。</li><li>@ArrayRes：R.array 类型资源。</li><li>@AttrRes：R.attr 类型资源。</li><li>@BoolRes：R.bool 类型资源。</li><li>@ColorRes：R.color 类型资源。</li><li>@DimenRes：R.dimen 类型资源。</li><li>@DrawableRes：R.drawable 类型资源。</li><li>@FractionRes：R.fraction 类型资源。（百分比）</li><li>@IdRes：R.id 类型资源。</li><li>@InterpolatorRes：R.interpolator 类型资源。（插值器）</li><li>@LayoutRes：R.layout 类型资源。</li><li>@MenuRes：R.menu 类型资源。</li><li>@PluralsRes：R.plurals 类型资源。（复数）</li><li>@RawRes：R.raw 类型资源。</li><li>@StyleableRes：R.styleable 类型资源。</li><li>@StyleRes：R.style 类型资源。</li><li>@TransitionRes： R.transition 类型资源。</li><li>@XmlRes：R.xml 类型资源。</li><li>@AnyRes：未知资源。（表示自己不知道是什么类型的资源。比如有可能为 R.drawable 也有可能是 R.string。）</li></ul><h2 id="ColorInt"><a href="#ColorInt" class="headerlink" title="@ColorInt"></a>@ColorInt</h2><p>@ColorInt 注解的作用为：限定颜色值。（ARGB：0xAARRGGBB）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果直接使用资源 id，则会报错，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setColor(R.color.colorAccent)<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><p>正确的使用是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setColor(<span class="number">0xFFFF00FF</span>);</span><br></pre></td></tr></table></figure></p><p>如果要使用资源 id，则可以通过 ContextCompat.getColor() 方法来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setColor(ContextCompat.getColor(context, R.color.colorAccent));</span><br></pre></td></tr></table></figure></p><h2 id="CallSuper"><a href="#CallSuper" class="headerlink" title="@CallSuper"></a>@CallSuper</h2><p>该注解用于修饰方法，表示重写该方法时必须调用 super 方法。如 onCreate() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写 onCreate() 方法时，必须调用 super 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br></pre></td></tr></table></figure></p><p>否则报错。</p><h2 id="VisibleForTesting-amp-Keep"><a href="#VisibleForTesting-amp-Keep" class="headerlink" title="@VisibleForTesting &amp; @Keep"></a>@VisibleForTesting &amp; @Keep</h2><p>使用 @VisibleForTesting 和 @Keep 注解可以表示方法、类、或字段的可访问性。</p><ul><li><p>@VisibleForTesting：该注解只起到一个注释的作用，告诉其他开发者被标记的代码为什么有这么大的可见程度（为了测试方便）。因此，经常用来修饰 public 或 protected，用来修饰 private 并不会报错，但是没有意义。</p></li><li><p>@Keep：标记的指定代码在混淆时不会被混淆。</p></li></ul><blockquote><p>参考：</p></blockquote><ul><li><a href="https://developer.android.com/studio/write/annotations.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/studio/write/annotations.html?hl=zh-cn</a></li><li><a href="http://droidyue.com/blog/2016/08/14/android-annnotation/" target="_blank" rel="noopener">http://droidyue.com/blog/2016/08/14/android-annnotation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Support Library 从 19.1 版本开始引入了一个新的注解库（Android Support Annotations Library），其中包含了很多的元注解，使用它们修饰我们的代码， 可以让我们提高程序的开发效率，让我们更早的发现问题。以及对代码施以规范，让代码更加有可读性。这篇文章就来简单了解下这些注解，以及其使用。如有错误和遗漏，欢迎留言和补充～&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://airsaid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://airsaid.github.io/tags/Android/"/>
    
      <category term="注解" scheme="http://airsaid.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="代码优化" scheme="http://airsaid.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 中接口的默认方法与静态方法</title>
    <link href="http://airsaid.github.io/20180201/Java8-Interface-DefaultMethod-StaticMethod/"/>
    <id>http://airsaid.github.io/20180201/Java8-Interface-DefaultMethod-StaticMethod/</id>
    <published>2018-02-01T07:48:19.000Z</published>
    <updated>2018-02-05T13:21:35.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Java 8 中，接口引入了一些新的语言特性：默认方法（Default Methods）以及静态方法（Static Methods）。本篇文章就来了解下这两个特性。</p></blockquote><a id="more"></a><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="默认方法的定义"><a href="#默认方法的定义" class="headerlink" title="默认方法的定义"></a>默认方法的定义</h3><p>默认方法的定义需要用到 default 关键字，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认方法不可以被 private 修饰，默认就是 public 的，public 可以省略不写。</p><h3 id="默认方法的使用"><a href="#默认方法的使用" class="headerlink" title="默认方法的使用"></a>默认方法的使用</h3><p>当有类实现了该接口后，可以直接调用该默认方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> C().getName());<span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在具体的接口实现类中也可以对接口中的默认方法进行覆写。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> C().getName());<span class="comment">// C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法的继承"><a href="#默认方法的继承" class="headerlink" title="默认方法的继承"></a>默认方法的继承</h3><p>大家都知道，接口与接口之间是可以继承的。那么在有默认方法的情况下，接口的继承又是什么样子的呢？<br>我们来看看下面的继承例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> A()&#123;&#125;.getName());<span class="comment">// A</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> B()&#123;&#125;.getName());<span class="comment">// A</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> C()&#123;&#125;.getName());<span class="comment">// C</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> D()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.getName());<span class="comment">// D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过打印结果，我们可以发现其继承关系有这么几种情况：</p><ul><li>不覆写父接口的默认方法，直接用父接口的方法实现。（参考 B 接口）</li><li>覆写父接口的默认方法，用自己的实现。（参考 C 接口）</li><li>覆写父接口的默认方法实现，并将其更改为抽象方法。（参考 D 接口）</li></ul><p>前两个很好理解，就跟类的继承是一样的。第三个呢，当把默认方法改为抽象方法后，那么实现类就必须去实现该抽象方法了。</p><h3 id="为什么要有默认方法"><a href="#为什么要有默认方法" class="headerlink" title="为什么要有默认方法"></a>为什么要有默认方法</h3><p>想象一个场景，假如在没有默认方法的情况下我们需要对集合框架增加一个新的迭代功能（forEach），那么我们就需要对其 Iterable 接口增加一个新的抽象方法，但是这样做的后果就是该接口下的所有实现类都必须去实现该方法。可是由于集合框架体系的庞大，实现类有非常多个，一改动全身，影响实在是太大，并不可取。</p><p>但是当有默认方法时，就解决了这个问题，就算在接口中增加了新的默认方法，具体的实现类也无需改动就有了新功能。</p><p>默认方法的出现就是为了保证原有代码兼容性的同时在接口中增加新的功能。</p><h3 id="默认方法带来的问题"><a href="#默认方法带来的问题" class="headerlink" title="默认方法带来的问题"></a>默认方法带来的问题</h3><p>默认方法虽好，但是我们也不可以滥用。因为默认方法会在复杂的继承关系中给我们的程序带来歧义以及编译错误。</p><p>由于接口是可以被多继承的，所以我们来看下面这种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 C 类同时实现 A、B 接口时，编译是无法通过的。很明显，因为 A、B 接口中都有 getName() 方法，要是能编译通过的话，程序怎么会知道调用哪个呢？所以出现这种情况，C 类必须去覆写 getName() 方法，然后给出自己的想要的 “结果”，例如，用 A 的 “结果”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.<span class="keyword">super</span>.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者说是自己给一个 “结果”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当最终调用的时候，打印结果就是：A、C 了。</p><p>另外还有一种稍复杂的情况，来看下这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//            return A.super.getName();// 报错</span></span><br><span class="line">            <span class="keyword">return</span> B.<span class="keyword">super</span>.getName();<span class="comment">// 正确</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> C().getName());<span class="comment">// B</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> D().getName());<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 这个类同时实现了 A 、B 接口，怎么就不报错让其实现 getName() 方法了呢？仔细看，B 和 A 是继承的关系。当 B 继承 A 后并覆写了 getName() 方法，那么 A 的 getName() 其实已经被屏蔽了。当同时实现这两个接口时，打印出的自然是 B 的 “结果” 了。同理，D 类中不可用 A 接口的实现也是如此。</p><blockquote><p>这是当接口继承行为发生冲突时的规则之一，即 被其他类型所覆盖的方法会被忽略。</p></blockquote><p>但是，我们就是想要 A 接口的结果，这怎么办？我们可以来新定义一个接口来解决该问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="keyword">super</span>.getName();<span class="comment">// 注意，这里必须去调用 A 接口的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> C.<span class="keyword">super</span>.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> D().getName());<span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕了一圈，总算是得到 A 的结果了。在该例子中，我们需要注意的是，在新定义的接口中，必须去调用 A 接口的实现，如果不调用的话，A 接口中的 getName() 方法依然会被 B 接口覆写导致屏蔽。切记切记！</p><h2 id="默认方法总结"><a href="#默认方法总结" class="headerlink" title="默认方法总结"></a>默认方法总结</h2><p>默认方法给予我们修改接口并且不破坏原有实现类提供了便利。但是同时也带来了一些问题，比如上文中提到了继承冲突。以及接口与类的关系由约束及实现而变得更加模糊。因此，我们应该在定义默认方法之前思考下是否真的必须这样做。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>从 Java 8 开始，接口除了可以定义默认方法外，还可以定义静态方法。</p><p>接口中静态方法的定义和类中的定义差不多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只不过在接口中，默认是由 public 所修饰的，并且同默认方法一样，是不可以更改为 private 的。</p><p>调用时，直接接口名.方法名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.print();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Java 8 中，接口引入了一些新的语言特性：默认方法（Default Methods）以及静态方法（Static Methods）。本篇文章就来了解下这两个特性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://airsaid.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://airsaid.github.io/tags/Java/"/>
    
      <category term="Java 8" scheme="http://airsaid.github.io/tags/Java-8/"/>
    
  </entry>
  
</feed>
